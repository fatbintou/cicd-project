name: üöÄ Django CI/CD Pipeline

on:
  push:
    branches: [ main, develop, staging ]
  pull_request:
    branches: [ main, develop, staging ]
  release:
    types: [published]

env:
  AWS_REGION: eu-west-1
  ECR_REPOSITORY: django-rest-app
  PROJECT_NAME: django-rest-aws
  PYTHON_VERSION: '3.11'
  POSTGRES_VERSION: '13'

jobs:
  # === QUALIT√â DU CODE ===
  lint:
    name: "üîç Lint & Code Quality"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          
      - name: Install dependencies
        run: |
          cd app
          pip install black flake8 mypy

      - name: Run Black
        run: |
          cd app
          black --check .

      - name: Run Flake8
        run: |
          cd app
          flake8 .

  # === TESTS ===
  unit-tests:
    name: "üß™ Unit Tests"
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.9,  3.11]
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install dependencies
      run: |
        cd app
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-django pytest-cov
    
    - name: Run migrations
      run: |
        cd app
        python manage.py makemigrations
        python manage.py migrate
      env:
        DEBUG: 'True'
        DJANGO_SECRET_KEY: 'test-secret-key'
        POSTGRES_DB: testdb
        POSTGRES_USER: testuser
        POSTGRES_PASSWORD: testpass
        POSTGRES_HOST: localhost
        POSTGRES_PORT: 5432
    
    - name: Run tests
      run: |
        cd app
        pytest --cov=myproject --cov-report=xml --cov-report=html -v
      env:
        DEBUG: 'True'
        DJANGO_SECRET_KEY: 'test-secret-key'
        POSTGRES_DB: testdb
        POSTGRES_USER: testuser
        POSTGRES_PASSWORD: testpass
        POSTGRES_HOST: localhost
        POSTGRES_PORT: 5432

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./app/coverage.xml
        flags: unittests

  # === S√âCURIT√â ===
  security-scan:
    name: "üõ°Ô∏è Security Scan"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          cd app
          pip install bandit safety

      - name: Run Bandit security scan
        run: |
          cd app
          bandit -r myproject/ -f html -o bandit-report.html || true

      - name: Run Safety check
        run: |
          cd app
          safety check --json --output safety-report.json || true

      - name: Upload security reports
        uses: actions/upload-artifact@v4
        with:
          name: security-reports
          path: |
            app/bandit-report.html
            app/safety-report.json
          retention-days: 30

  # === BUILD & PUSH ===
  build-and-push:
    name: "üèóÔ∏è Build & Push to ECR"
    runs-on: ubuntu-latest
    needs: [unit-tests, security-scan]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/staging' || github.event_name == 'release'
    
    outputs:
      image-tag: ${{ steps.get-tag.outputs.image-tag }}
      environment: ${{ steps.get-env.outputs.environment }}

    steps:
    - uses: actions/checkout@v4

    - name: Determine environment and tag
      id: get-env
      run: |
        if [ "${{ github.ref }}" == "refs/heads/develop" ]; then
          echo "environment=development" >> $GITHUB_OUTPUT
        elif [ "${{ github.ref }}" == "refs/heads/staging" ]; then
          echo "environment=staging" >> $GITHUB_OUTPUT
        elif [ "${{ github.ref }}" == "refs/heads/main" ] || [ "${{ github.event_name }}" == "release" ]; then
          echo "environment=production" >> $GITHUB_OUTPUT
        fi

    - name: Get image tag
      id: get-tag
      run: |
        SHORT_SHA=${GITHUB_SHA:0:8}
        echo "image-tag=$SHORT_SHA" >> $GITHUB_OUTPUT

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push Web image
      uses: docker/build-push-action@v5
      with:
        context: ./app
        file: ./app/Dockerfile
        push: true
        tags: |
          ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}-web:latest
          ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}-web:${{ steps.get-tag.outputs.image-tag }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          ENVIRONMENT=${{ steps.get-env.outputs.environment }}

    - name: Build and push Nginx image
      uses: docker/build-push-action@v5
      with:
        context: ./nginx
        file: ./nginx/Dockerfile
        push: true
        tags: |
          ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}-nginx:latest
          ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}-nginx:${{ steps.get-tag.outputs.image-tag }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Generate deployment info
      run: |
        echo "Environment: ${{ steps.get-env.outputs.environment }}"
        echo "Image Tag: ${{ steps.get-tag.outputs.image-tag }}"
        echo "ECR Registry: ${{ steps.login-ecr.outputs.registry }}"

  # === D√âPLOIEMENT DEVELOPMENT ===
  deploy-development:
    name: "üå± Deploy to Development"
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/develop' && needs.build-and-push.outputs.environment == 'development'
    environment: development
    
    steps:
    - uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Deploy to Development
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.AWS_EC2_HOST_DEV }}
        username: ${{ secrets.AWS_SSH_USER_DEV }}
        key: ${{ secrets.AWS_SSH_PRIVATE_KEY_DEV }}
        script: |
          set -e
          echo "üîÑ Deploying to Development..."
          
          # Create app directory if it doesn't exist
          mkdir -p /home/${{ secrets.AWS_SSH_USER_DEV }}/app
          cd /home/${{ secrets.AWS_SSH_USER_DEV }}/app
          
          # Login to ECR
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
          docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          
          # Pull latest images
          docker-compose -f docker-compose.development.yml pull web nginx
          
          # Stop and remove old containers
          docker-compose -f docker-compose.development.yml down
          
          # Start new containers
          docker-compose -f docker-compose.development.yml up -d
          
          # Wait for services to be ready
          echo "‚è≥ Waiting for services to be healthy..."
          sleep 30
          
          # Health check
          echo "üè• Running health check..."
          MAX_RETRIES=10
          for i in $(seq 1 $MAX_RETRIES); do
            if curl -f http://localhost/api/books/ > /dev/null 2>&1; then
              echo "‚úÖ Health check passed!"
              break
            fi
            echo "‚è≥ Health check attempt $i/$MAX_RETRIES failed, retrying..."
            sleep 10
          done
          
          # Cleanup old images
          echo "üßπ Cleaning up unused images..."
          docker image prune -f
          
          echo "‚úÖ Development deployment completed successfully!"

  # === D√âPLOIEMENT STAGING ===
  deploy-staging:
    name: "üü° Deploy to Staging"
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/staging' && needs.build-and-push.outputs.environment == 'staging'
    environment: staging
    
    steps:
    - uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Deploy to Staging
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.AWS_EC2_HOST_STAGING }}
        username: ${{ secrets.AWS_SSH_USER_STAGING }}
        key: ${{ secrets.AWS_SSH_PRIVATE_KEY_STAGING }}
        script: |
          set -e
          echo "üü° Deploying to Staging..."
          
          # Create app directory if it doesn't exist
          mkdir -p /home/${{ secrets.AWS_SSH_USER_STAGING }}/app
          cd /home/${{ secrets.AWS_SSH_USER_STAGING }}/app
          
          # Login to ECR
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
          docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          
          # Pull latest images
          docker-compose -f docker-compose.staging.yml pull web nginx
          
          # Stop and remove old containers
          docker-compose -f docker-compose.staging.yml down
          
          # Start new containers
          docker-compose -f docker-compose.staging.yml up -d
          
          # Wait for services to be ready
          echo "‚è≥ Waiting for services to be healthy..."
          sleep 30
          
          # Health check
          echo "üè• Running health check..."
          MAX_RETRIES=10
          for i in $(seq 1 $MAX_RETRIES); do
            if curl -f http://localhost/api/books/ > /dev/null 2>&1; then
              echo "‚úÖ Health check passed!"
              break
            fi
            echo "‚è≥ Health check attempt $i/$MAX_RETRIES failed, retrying..."
            sleep 10
          done
          
          # Cleanup old images
          echo "üßπ Cleaning up unused images..."
          docker image prune -f
          
          echo "‚úÖ Staging deployment completed successfully!"

  # === D√âPLOIEMENT PRODUCTION ===
  deploy-production:
    name: "üöÄ Deploy to Production"
    runs-on: ubuntu-latest
    needs: build-and-push
    if: (github.ref == 'refs/heads/main' || github.event_name == 'release') && needs.build-and-push.outputs.environment == 'production'
    environment: production
    
    steps:
    - uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Deploy to Production
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.AWS_EC2_HOST_PROD }}
        username: ${{ secrets.AWS_SSH_USER_PROD }}
        key: ${{ secrets.AWS_SSH_PRIVATE_KEY_PROD }}
        script: |
          set -e
          echo "üöÄ Deploying to Production..."
          
          # Create app directory if it doesn't exist
          mkdir -p /home/${{ secrets.AWS_SSH_USER_PROD }}/app
          cd /home/${{ secrets.AWS_SSH_USER_PROD }}/app
          
          # Login to ECR
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
          docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          
          # Pull latest images
          docker-compose -f docker-compose.production.yml pull web nginx
          
          # Stop and remove old containers
          docker-compose -f docker-compose.production.yml down
          
          # Start new containers
          docker-compose -f docker-compose.production.yml up -d
          
          # Wait for services to be ready
          echo "‚è≥ Waiting for services to be healthy..."
          sleep 30
          
          # Health check
          echo "üè• Running health check..."
          MAX_RETRIES=10
          for i in $(seq 1 $MAX_RETRIES); do
            if curl -f http://localhost/api/books/ > /dev/null 2>&1; then
              echo "‚úÖ Health check passed!"
              break
            fi
            echo "‚è≥ Health check attempt $i/$MAX_RETRIES failed, retrying..."
            sleep 10
          done
          
          # Cleanup old images
          echo "üßπ Cleaning up unused images..."
          docker image prune -f
          
          echo "‚úÖ Production deployment completed successfully!"

  # === NOTIFICATIONS ===
  notify:
    name: "üì¢ Notification"
    needs: [deploy-development, deploy-staging, deploy-production]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Send workflow status
        run: |
          DEPLOYMENT_RESULT="${{ needs.deploy-production.result || needs.deploy-staging.result || needs.deploy-development.result || 'success' }}"
          ENVIRONMENT=""
          if [ "${{ needs.deploy-production.result }}" != "" ]; then
            ENVIRONMENT="production"
          elif [ "${{ needs.deploy-staging.result }}" != "" ]; then
            ENVIRONMENT="staging"
          elif [ "${{ needs.deploy-development.result }}" != "" ]; then
            ENVIRONMENT="development"
          fi
          
          echo "üöÄ Deployment Summary"
          echo "===================="
          echo "Status: $DEPLOYMENT_RESULT"
          echo "Environment: $ENVIRONMENT"
          echo "Repository: ${{ github.repository }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "Workflow Run: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          if [ "$DEPLOYMENT_RESULT" == "success" ]; then
            echo "‚úÖ Deployment completed successfully!"
          else
            echo "‚ùå Deployment failed!"
            exit 1
          fi